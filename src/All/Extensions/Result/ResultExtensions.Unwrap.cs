// Wrap: .NET monads.
// Copyright (c) bfren - licensed under https://mit.bfren.dev/2019

using System;
using System.Threading.Tasks;
using Wrap.Exceptions;

namespace Wrap.Extensions;

public static partial class ResultExtensions
{
	#region Throw Exception on Failure

	/// <summary>
	/// Unwrap the value contained in <paramref name="this"/> - throws an exception if the result is <see cref="Failure"/>.
	/// </summary>
	/// <typeparam name="T">Ok value type.</typeparam>
	/// <param name="this">Result object.</param>
	/// <returns>The value of <paramref name="this"/> or throws an exception.</returns>
	/// <exception cref="FailureException"></exception>
	public static Task<T> UnwrapAsync<T>(this Task<Result<T>> @this)
	{
		// use local functions to avoid function signature ambiguity
		static Task<T> fail(FailureValue f) => R.ThrowFailure<Task<T>>(f);
		static async Task<T> ok(T x) => x;
		return R.MatchAsync(@this, fail, ok);
	}

	#endregion

	#region Return Value on Failure

	/// <summary>
	/// Unwrap the value contained in <paramref name="this"/>.
	/// </summary>
	/// <remarks>
	/// <para>
	/// Provides access to the value wrapped by a <see cref="Result{T}"/> object.
	/// </para>
	/// <para>
	/// You need to provide a default value via <paramref name="ifFailed"/> in case
	/// <paramref name="this"/> is <see cref="Failure"/>.
	/// </para>
	/// </remarks>
	/// <typeparam name="T">Ok value type.</typeparam>
	/// <param name="this">Result object.</param>
	/// <param name="ifFailed">Function to generate a value if <paramref name="this"/> is <see cref="Failure"/>.</param>
	/// <returns>The value of <paramref name="this"/> or generated by <paramref name="ifFailed"/>.</returns>
	public static Task<T> UnwrapAsync<T>(this Result<T> @this, Func<FailureValue, Task<T>> ifFailed) =>
		R.MatchAsync(@this,
			fFail: ifFailed,
			fOk: x => x
		);

	/// <inheritdoc cref="UnwrapAsync{T}(Result{T}, Func{FailureValue, Task{T}})"/>
	public static Task<T> UnwrapAsync<T>(this Task<Result<T>> @this, Func<FailureValue, T> ifFailed) =>
		R.MatchAsync(@this,
			fFail: ifFailed,
			fOk: async x => x
		);

	/// <inheritdoc cref="UnwrapAsync{T}(Result{T}, Func{FailureValue, Task{T}})"/>
	public static Task<T> UnwrapAsync<T>(this Task<Result<T>> @this, Func<FailureValue, Task<T>> ifFailed) =>
		R.MatchAsync(@this,
			fFail: ifFailed,
			fOk: async x => x
		);

	#endregion

	#region Handle Failure then Return Value

	/// <summary>
	/// Unwrap the value contained in <paramref name="this"/>.
	/// </summary>
	/// <remarks>
	/// <para>
	/// Provides access to the value wrapped by a <see cref="Result{T}"/> object.
	/// </para>
	/// <para>
	/// You need to provide a default value via <paramref name="returnThis"/> in case
	/// <paramref name="this"/> is <see cref="Failure"/>.
	/// </para>
	/// </remarks>
	/// <typeparam name="T">Ok value type.</typeparam>
	/// <param name="this">Result object.</param>
	/// <param name="ifFailed">Function to handle a FailureValue.</param>
	/// <param name="returnThis">Function to return a value on a Failure.</param>
	/// <returns>The value of <paramref name="this"/> or generated by <paramref name="returnThis"/>.</returns>
	public static Task<T> UnwrapAsync<T>(this Result<T> @this, Func<FailureValue, Task> ifFailed, Func<Task<T>> returnThis) =>
		R.MatchAsync(@this,
			fFail: async f => { await ifFailed(f); return await returnThis(); },
			fOk: x => x
		);

	/// <inheritdoc cref="UnwrapAsync{T}(Result{T}, Func{FailureValue, Task}, Func{Task{T}})"/>
	public static Task<T> UnwrapAsync<T>(this Result<T> @this, Func<FailureValue, Task> ifFailed, Func<T> returnThis) =>
		R.MatchAsync(@this,
			fFail: async f => { await ifFailed(f); return returnThis(); },
			fOk: x => x
		);

	/// <inheritdoc cref="UnwrapAsync{T}(Result{T}, Func{FailureValue, Task}, Func{Task{T}})"/>
	public static Task<T> UnwrapAsync<T>(this Result<T> @this, Action<FailureValue> ifFailed, Func<Task<T>> returnThis) =>
		R.MatchAsync(@this,
			fFail: async f => { ifFailed(f); return await returnThis(); },
			fOk: x => x
		);

	/// <inheritdoc cref="UnwrapAsync{T}(Result{T}, Func{FailureValue, Task}, Func{T})"/>
	public static Task<T> UnwrapAsync<T>(this Task<Result<T>> @this, Action<FailureValue> ifFailed, Func<T> returnThis) =>
		R.MatchAsync(@this,
			fFail: async f => { ifFailed(f); return returnThis(); },
			fOk: x => x
		);

	/// <inheritdoc cref="UnwrapAsync{T}(Result{T}, Func{FailureValue, Task}, Func{T})"/>
	public static Task<T> UnwrapAsync<T>(this Task<Result<T>> @this, Func<FailureValue, Task> ifFailed, Func<T> returnThis) =>
		R.MatchAsync(@this,
			fFail: async f => { await ifFailed(f); return returnThis(); },
			fOk: x => x
		);

	/// <inheritdoc cref="UnwrapAsync{T}(Result{T}, Func{FailureValue, Task}, Func{T})"/>
	public static Task<T> UnwrapAsync<T>(this Task<Result<T>> @this, Action<FailureValue> ifFailed, Func<Task<T>> returnThis) =>
		R.MatchAsync(@this,
			fFail: async f => { ifFailed(f); return await returnThis(); },
			fOk: x => x
		);

	/// <inheritdoc cref="UnwrapAsync{T}(Result{T}, Func{FailureValue, Task}, Func{T})"/>
	public static Task<T> UnwrapAsync<T>(this Task<Result<T>> @this, Func<FailureValue, Task> ifFailed, Func<Task<T>> returnThis) =>
		R.MatchAsync(@this,
			fFail: async f => { await ifFailed(f); return await returnThis(); },
			fOk: x => x
		);

	#endregion
}
