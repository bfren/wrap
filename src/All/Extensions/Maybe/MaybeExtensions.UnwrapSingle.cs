// Wrap: .NET monads.
// Copyright (c) bfren - licensed under https://mit.bfren.dev/2019

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace Wrap.Extensions;

public static partial class MaybeExtensions
{
	/// <summary>
	/// Unwrap an <see cref="IEnumerable{T}"/> object that has a single value.
	/// </summary>
	/// <remarks>
	/// <para>
	/// If <paramref name="this"/> is not an <see cref="IEnumerable{T}"/> with a single value,
	/// you will get an <see cref="InvalidOperationException"/>.
	/// </para>
	/// </remarks>
	/// <seealso cref="Maybe{T}.Unwrap(Func{None, T})"/>
	/// <typeparam name="T">Some value type - limited to <see cref="IEnumerable{TSingle}"/>.</typeparam>
	/// <typeparam name="TSingle">IEnumerable value type.</typeparam>
	/// <param name="this">Maybe object.</param>
	/// <param name="fNone">Function to generate a value if <paramref name="this"/> is <see cref="None"/>.</param>
	/// <returns>The single value contained in <paramref name="this"/>, or one generated by <paramref name="fNone"/></returns>
	public static TSingle UnwrapSingle<T, TSingle>(this Maybe<T> @this, Func<TSingle> fNone)
		where T : IEnumerable<TSingle> =>
		Match(@this,
			fNone: fNone,
			fSome: x => x.Single()
		);

	/// <inheritdoc cref="UnwrapSingle{T, TSingle}(Maybe{T}, Func{TSingle})"/>
	public static Task<TSingle> UnwrapSingleAsync<T, TSingle>(this Maybe<T> @this, Func<Task<TSingle>> fNone)
		where T : IEnumerable<TSingle> =>
		MatchAsync(@this,
			fNone: fNone,
			fSome: x => x.Single()
		);

	/// <inheritdoc cref="UnwrapSingle{T, TSingle}(Maybe{T}, Func{TSingle})"/>
	public static Task<TSingle> UnwrapSingleAsync<T, TSingle>(this Task<Maybe<T>> @this, Func<TSingle> fNone)
		where T : IEnumerable<TSingle> =>
		MatchAsync(@this,
			fNone: fNone,
			fSome: x => x.Single()
		);

	/// <inheritdoc cref="UnwrapSingle{T, TSingle}(Maybe{T}, Func{TSingle})"/>
	public static Task<TSingle> UnwrapSingleAsync<T, TSingle>(this Task<Maybe<T>> @this, Func<Task<TSingle>> fNone)
		where T : IEnumerable<TSingle> =>
		MatchAsync(@this,
			fNone: fNone,
			fSome: x => x.Single()
		);
}
