// Wrap: Functional Monads for .NET
// Copyright (c) bfren - licensed under https://mit.bfren.dev/2019

using System;
using System.Threading.Tasks;
using Wrap.Exceptions;

namespace Wrap;

public static partial class E
{
	#region Without Return Value

	/// <summary>
	/// Run an action based on the value of <paramref name="either"/>.
	/// </summary>
	/// <remarks>
	/// <para>
	/// It would be possible to achieve the same thing using switch statements, but doing that would add the
	/// potential for not handling both cases (<see cref="Right{TLeft, TRight}"/> and <see cref="Left{TLeft, TRight}"/>).
	/// </para>
	/// <para>
	/// This way there has to be a function to handle both cases.
	/// </para>
	/// </remarks>
	/// <typeparam name="TEither">Either implementation type.</typeparam>
	/// <typeparam name="TLeft">Left (error / invalid) value type.</typeparam>
	/// <typeparam name="TRight">Right (correct / valid) value type.</typeparam>
	/// <param name="either">Result object.</param>
	/// <param name="fLeft">Function to run when <paramref name="either"/> is <see cref="Left{TLeft, TRight}"/>.</param>
	/// <param name="fRight">Function to run when <paramref name="either"/> is <see cref="Right{TLeft, TRight}"/>.</param>
	/// <exception cref="InvalidEitherTypeException"></exception>
	/// <exception cref="NullEitherException"></exception>
	public static void Match<TEither, TLeft, TRight>(TEither either, Action<TLeft> fLeft, Action<TRight> fRight)
		where TEither : IEither<TEither, TLeft, TRight>
	{
		Action f = either switch
		{
			ILeft<TLeft, TRight> x =>
				() => fLeft(x.Value),

			IRight<TLeft, TRight> y =>
				() => fRight(y.Value),

			{ } m =>
				throw new InvalidEitherTypeException(m.GetType()),

			_ =>
				throw new NullEitherException()
		};

		f();
	}

	/// <inheritdoc cref="Match{TEither, TLeft, TRight}(TEither, Action{TLeft}, Action{TRight})"/>
	public static Task MatchAsync<TEither, TLeft, TRight>(TEither either, Action<TLeft> fLeft, Func<TRight, Task> fRight)
		where TEither : IEither<TEither, TLeft, TRight> =>
		MatchAsync<TEither, TLeft, TRight>(either.AsTask(), async x => fLeft(x), fRight);

	/// <inheritdoc cref="Match{TEither, TLeft, TRight}(TEither, Action{TLeft}, Action{TRight})"/>
	public static Task MatchAsync<TEither, TLeft, TRight>(TEither either, Func<TLeft, Task> fLeft, Action<TRight> fRight)
		where TEither : IEither<TEither, TLeft, TRight> =>
		MatchAsync<TEither, TLeft, TRight>(either.AsTask(), fLeft, async x => fRight(x));

	/// <inheritdoc cref="Match{TEither, TLeft, TRight}(TEither, Action{TLeft}, Action{TRight})"/>
	public static Task MatchAsync<TEither, TLeft, TRight>(TEither either, Func<TLeft, Task> fLeft, Func<TRight, Task> fRight)
		where TEither : IEither<TEither, TLeft, TRight> =>
		MatchAsync(either.AsTask(), fLeft, fRight);

	/// <inheritdoc cref="Match{TEither, TLeft, TRight}(TEither, Action{TLeft}, Action{TRight})"/>
	public static async Task MatchAsync<TEither, TLeft, TRight>(Task<TEither> either, Func<TLeft, Task> fLeft, Func<TRight, Task> fRight)
		where TEither : IEither<TEither, TLeft, TRight> =>
		Match<TEither, TLeft, TRight>(await either, async x => await fLeft(x), async x => await fRight(x));

	#endregion

	#region With Return Value

	/// <summary>
	/// Run a function based on the value of <paramref name="either"/> and return its value.
	/// </summary>
	/// <remarks>
	/// <para>
	/// It would be possible to achieve the same thing using switch statements, but doing that would add the
	/// potential for not handling both cases (<see cref="Right{TLeft, TRight}"/> and <see cref="Left{TLeft, TRight}"/>).
	/// </para>
	/// <para>
	/// This way there has to be a function to handle both cases.
	/// </para>
	/// </remarks>
	/// <typeparam name="TEither">Either implementation type.</typeparam>
	/// <typeparam name="TLeft">Left (error / invalid) value type.</typeparam>
	/// <typeparam name="TRight">Right (correct / valid) value type.</typeparam>
	/// <typeparam name="TReturn">Return value type.</typeparam>
	/// <param name="either">Result object.</param>
	/// <param name="fLeft">Function to run when <paramref name="either"/> is <see cref="Left{TLeft, TRight}"/>.</param>
	/// <param name="fRight">Function to run when <paramref name="either"/> is <see cref="Right{TLeft, TRight}"/>.</param>
	/// <returns>Value generated by either <paramref name="fLeft"/> or <paramref name="fRight"/>.</returns>
	/// <exception cref="InvalidEitherTypeException"></exception>
	/// <exception cref="NullEitherException"></exception>
	public static TReturn Match<TEither, TLeft, TRight, TReturn>(TEither either, Func<TLeft, TReturn> fLeft, Func<TRight, TReturn> fRight)
		where TEither : IEither<TEither, TLeft, TRight> =>
		either switch
		{
			ILeft<TLeft, TRight> x =>
				fLeft(x.Value),

			IRight<TLeft, TRight> y =>
				fRight(y.Value),

			{ } r =>
				throw new InvalidEitherTypeException(r.GetType()),

			_ =>
				throw new NullEitherException()
		};

	/// <inheritdoc cref="Match{TEither, TLeft, TRight, TReturn}(TEither, Func{TLeft, TReturn}, Func{TRight, TReturn})"/>
	public static Task<TReturn> MatchAsync<TEither, TLeft, TRight, TReturn>(TEither either, Func<TLeft, TReturn> fLeft, Func<TRight, Task<TReturn>> fRight)
		where TEither : IEither<TEither, TLeft, TRight> =>
		MatchAsync<TEither, TLeft, TRight, TReturn>(either.AsTask(), async x => fLeft(x), fRight);

	/// <inheritdoc cref="Match{TEither, TLeft, TRight, TReturn}(TEither, Func{TLeft, TReturn}, Func{TRight, TReturn})"/>
	public static Task<TReturn> MatchAsync<TEither, TLeft, TRight, TReturn>(TEither either, Func<TLeft, Task<TReturn>> fLeft, Func<TRight, TReturn> fRight)
		where TEither : IEither<TEither, TLeft, TRight> =>
		MatchAsync<TEither, TLeft, TRight, TReturn>(either.AsTask(), fLeft, async x => fRight(x));

	/// <inheritdoc cref="Match{TEither, TLeft, TRight, TReturn}(TEither, Func{TLeft, TReturn}, Func{TRight, TReturn})"/>
	public static Task<TReturn> MatchAsync<TEither, TLeft, TRight, TReturn>(TEither either, Func<TLeft, Task<TReturn>> fLeft, Func<TRight, Task<TReturn>> fRight)
		where TEither : IEither<TEither, TLeft, TRight> =>
		MatchAsync(either.AsTask(), fLeft, fRight);

	/// <inheritdoc cref="Match{TEither, TLeft, TRight, TReturn}(TEither, Func{TLeft, TReturn}, Func{TRight, TReturn})"/>
	public static Task<TReturn> MatchAsync<TEither, TLeft, TRight, TReturn>(Task<TEither> either, Func<TLeft, TReturn> fLeft, Func<TRight, TReturn> fRight)
		where TEither : IEither<TEither, TLeft, TRight> =>
		MatchAsync<TEither, TLeft, TRight, TReturn>(either, async x => fLeft(x), async x => fRight(x));

	/// <inheritdoc cref="Match{TEither, TLeft, TRight, TReturn}(TEither, Func{TLeft, TReturn}, Func{TRight, TReturn})"/>
	public static Task<TReturn> MatchAsync<TEither, TLeft, TRight, TReturn>(Task<TEither> either, Func<TLeft, TReturn> fLeft, Func<TRight, Task<TReturn>> fRight)
		where TEither : IEither<TEither, TLeft, TRight> =>
		MatchAsync<TEither, TLeft, TRight, TReturn>(either, async x => fLeft(x), fRight);

	/// <inheritdoc cref="Match{TEither, TLeft, TRight, TReturn}(TEither, Func{TLeft, TReturn}, Func{TRight, TReturn})"/>
	public static Task<TReturn> MatchAsync<TEither, TLeft, TRight, TReturn>(Task<TEither> either, Func<TLeft, Task<TReturn>> fLeft, Func<TRight, TReturn> fRight)
		where TEither : IEither<TEither, TLeft, TRight> =>
		MatchAsync<TEither, TLeft, TRight, TReturn>(either, fLeft, async x => fRight(x));

	/// <inheritdoc cref="Match{TEither, TLeft, TRight, TReturn}(TEither, Func{TLeft, TReturn}, Func{TRight, TReturn})"/>
	public static async Task<TReturn> MatchAsync<TEither, TLeft, TRight, TReturn>(Task<TEither> either, Func<TLeft, Task<TReturn>> fLeft, Func<TRight, Task<TReturn>> fRight)
		where TEither : IEither<TEither, TLeft, TRight> =>
		await Match(await either, fLeft, fRight);

	#endregion
}
