// Wrap: .NET monads.
// Copyright (c) bfren - licensed under https://mit.bfren.dev/2019

using System;
using System.Threading.Tasks;
using Wrap.Exceptions;

namespace Wrap;

public static partial class M
{
	#region Without Return Value

	/// <summary>
	/// Run an action based on the value of <paramref name="maybe"/>.
	/// </summary>
	/// <remarks>
	/// <para>
	/// It would be possible to achieve the same thing using switch statements, but doing that would add the
	/// potential for not handling both cases (<see cref="Some{T}"/> and <see cref="Wrap.None"/>).
	/// </para>
	/// <para>
	/// This way there has to be a function to handle both cases.
	/// </para>
	/// </remarks>
	/// <typeparam name="T">Some value type.</typeparam>
	/// <param name="maybe">Maybe object.</param>
	/// <param name="fNone">Function to run when <paramref name="maybe"/> is <see cref="Wrap.None"/>.</param>
	/// <param name="fSome">Function to run when <paramref name="maybe"/> is <see cref="Some{T}"/>.</param>
	/// <exception cref="InvalidMaybeTypeException"></exception>
	/// <exception cref="NullMaybeException"></exception>
	public static void Match<T>(Maybe<T> maybe, Action fNone, Action<T> fSome)
	{
		var f = maybe switch
		{
			Maybe<T>.NoneImpl =>
				fNone,

			Some<T> x =>
				() => fSome(x.Value),

			{ } m =>
				throw new InvalidMaybeTypeException(m.GetType()),

			_ =>
				throw new NullMaybeException()
		};

		f();
	}

	/// <inheritdoc cref="Match{T}(Maybe{T}, Action, Action{T})"/>
	public static Task MatchAsync<T>(Maybe<T> maybe, Action fNone, Func<T, Task> fSome) =>
		MatchAsync(Task.FromResult(maybe), async () => fNone(), fSome);

	/// <inheritdoc cref="Match{T}(Maybe{T}, Action, Action{T})"/>
	public static Task MatchAsync<T>(Maybe<T> maybe, Func<Task> fNone, Action<T> fSome) =>
		MatchAsync(Task.FromResult(maybe), fNone, async x => fSome(x));

	/// <inheritdoc cref="Match{T}(Maybe{T}, Action, Action{T})"/>
	public static Task MatchAsync<T>(Maybe<T> maybe, Func<Task> fNone, Func<T, Task> fSome) =>
		MatchAsync(Task.FromResult(maybe), fNone, fSome);

	/// <inheritdoc cref="Match{T}(Maybe{T}, Action, Action{T})"/>
	public static Task MatchAsync<T>(Task<Maybe<T>> maybe, Action fNone, Action<T> fSome) =>
		MatchAsync(maybe, async () => fNone(), async x => fSome(x));

	/// <inheritdoc cref="Match{T}(Maybe{T}, Action, Action{T})"/>
	public static Task MatchAsync<T>(Task<Maybe<T>> maybe, Action fNone, Func<T, Task> fSome) =>
		MatchAsync(maybe, async () => fNone(), fSome);

	/// <inheritdoc cref="Match{T}(Maybe{T}, Action, Action{T})"/>
	public static Task MatchAsync<T>(Task<Maybe<T>> maybe, Func<Task> fNone, Action<T> fSome) =>
		MatchAsync(maybe, fNone, async x => fSome(x));

	/// <inheritdoc cref="Match{T}(Maybe{T}, Action, Action{T})"/>
	public static async Task MatchAsync<T>(Task<Maybe<T>> maybe, Func<Task> fNone, Func<T, Task> fSome)
	{
		var f = await maybe switch
		{
			Maybe<T>.NoneImpl =>
				fNone,

			Some<T> x =>
				() => fSome(x.Value),

			{ } m =>
				throw new InvalidMaybeTypeException(m.GetType()),

			_ =>
				throw new NullMaybeException()
		};

		await f();
	}

	#endregion

	#region With Return Value

	/// <summary>
	/// Run a function based on the value of <paramref name="maybe"/> and return its value.
	/// </summary>
	/// <remarks>
	/// <para>
	/// It would be possible to achieve the same thing using switch statements, but doing that would add the
	/// potential for not handling both cases (<see cref="Some{T}"/> and <see cref="Wrap.None"/>).
	/// </para>
	/// <para>
	/// This way there has to be a function to handle both cases.
	/// </para>
	/// </remarks>
	/// <typeparam name="T">Some value type.</typeparam>
	/// <typeparam name="TReturn">Return value type.</typeparam>
	/// <param name="maybe">Maybe object.</param>
	/// <param name="fNone">Function to run when <paramref name="maybe"/> is <see cref="Wrap.None"/>.</param>
	/// <param name="fSome">Function to run when <paramref name="maybe"/> is <see cref="Some{T}"/>.</param>
	/// <returns>Value generated by either <paramref name="fNone"/> or <paramref name="fSome"/>.</returns>
	/// <exception cref="InvalidMaybeTypeException"></exception>
	/// <exception cref="NullMaybeException"></exception>
	public static TReturn Match<T, TReturn>(Maybe<T> maybe, Func<TReturn> fNone, Func<T, TReturn> fSome) =>
		maybe switch
		{
			Maybe<T>.NoneImpl =>
				fNone(),

			Some<T> x =>
				fSome(x.Value),

			{ } m =>
				throw new InvalidMaybeTypeException(m.GetType()),

			_ =>
				throw new NullMaybeException()
		};

	/// <inheritdoc cref="Match{T, TReturn}(Maybe{T}, Func{TReturn}, Func{T, TReturn})"/>
	public static Task<TReturn> MatchAsync<T, TReturn>(Maybe<T> maybe, Func<TReturn> fNone, Func<T, Task<TReturn>> fSome) =>
		Match(maybe, async () => fNone(), fSome);

	/// <inheritdoc cref="Match{T, TReturn}(Maybe{T}, Func{TReturn}, Func{T, TReturn})"/>
	public static Task<TReturn> MatchAsync<T, TReturn>(Maybe<T> maybe, Func<Task<TReturn>> fNone, Func<T, TReturn> fSome) =>
		Match(maybe, fNone, async x => fSome(x));

	/// <inheritdoc cref="Match{T, TReturn}(Maybe{T}, Func{TReturn}, Func{T, TReturn})"/>
	public static Task<TReturn> MatchAsync<T, TReturn>(Maybe<T> maybe, Func<Task<TReturn>> fNone, Func<T, Task<TReturn>> fSome) =>
		Match(maybe, fNone, fSome);

	/// <inheritdoc cref="Match{T, TReturn}(Maybe{T}, Func{TReturn}, Func{T, TReturn})"/>
	public static Task<TReturn> MatchAsync<T, TReturn>(Task<Maybe<T>> maybe, Func<TReturn> fNone, Func<T, TReturn> fSome) =>
		MatchAsync(maybe, async () => fNone(), async x => fSome(x));

	/// <inheritdoc cref="Match{T, TReturn}(Maybe{T}, Func{TReturn}, Func{T, TReturn})"/>
	public static Task<TReturn> MatchAsync<T, TReturn>(Task<Maybe<T>> maybe, Func<TReturn> fNone, Func<T, Task<TReturn>> fSome) =>
		MatchAsync(maybe, async () => fNone(), fSome);

	/// <inheritdoc cref="Match{T, TReturn}(Maybe{T}, Func{TReturn}, Func{T, TReturn})"/>
	public static Task<TReturn> MatchAsync<T, TReturn>(Task<Maybe<T>> maybe, Func<Task<TReturn>> fNone, Func<T, TReturn> fSome) =>
		MatchAsync(maybe, fNone, async x => fSome(x));

	/// <inheritdoc cref="Match{T, TReturn}(Maybe{T}, Func{TReturn}, Func{T, TReturn})"/>
	public static async Task<TReturn> MatchAsync<T, TReturn>(Task<Maybe<T>> maybe, Func<Task<TReturn>> fNone, Func<T, Task<TReturn>> fSome) =>
		await Match(await maybe, fNone, fSome);

	#endregion
}
